var boothApp,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

boothApp = angular.module('judgebooth', ['ionic', 'angular-cache', 'pascalprecht.translate', 'judgebooth.services', 'judgebooth.controllers', 'judgebooth.translations']);

boothApp.config([
  '$locationProvider', '$stateProvider', '$urlRouterProvider', function($locationProvider, $stateProvider, $urlRouterProvider) {
    $locationProvider.html5Mode(!window.offlineMode && navigator.onLine);
    $stateProvider.state('app', {
      url: '',
      abstract: true,
      templateUrl: 'views/menu.html',
      controller: 'SideCtrl'
    }).state('app.home', {
      url: '/',
      views: {
        menuContent: {
          templateUrl: 'views/home.html',
          controller: 'HomeCtrl'
        }
      }
    }).state('app.question', {
      url: '/question/:id',
      views: {
        menuContent: {
          templateUrl: 'views/question.html',
          controller: 'QuestionCtrl'
        }
      }
    }).state('app.admin', {
      url: '/admin',
      abstract: true
    }).state('app.admin.new', {
      url: '/new',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/new.html',
          controller: 'AdminNewCtrl'
        }
      }
    }).state('app.admin.questions', {
      url: '/questions/:page',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/questions.html',
          controller: 'AdminQuestionsCtrl'
        }
      }
    }).state('app.admin.question', {
      url: '/question/:id',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/question.html',
          controller: 'AdminQuestionCtrl'
        }
      }
    }).state('app.admin.translations', {
      url: '/translations',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/translations.html',
          controller: 'AdminTranslationsCtrl'
        }
      }
    }).state('app.admin.translation', {
      url: '/translation/:language/:id',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/translation.html',
          controller: 'AdminTranslationCtrl'
        }
      }
    }).state('app.admin.users', {
      url: '/users',
      views: {
        'menuContent@app': {
          templateUrl: 'views/admin/users.html',
          controller: 'AdminUsersCtrl'
        }
      }
    });
    return $urlRouterProvider.otherwise('/');
  }
]);

boothApp.config([
  '$translateProvider', function($translateProvider) {
    var availableLanguages, language, navigatorLanguage;
    availableLanguages = ["en", "br", "ru", "cn", "tw", "fr", "pt", "es", "jp"];
    navigatorLanguage = navigator.language || navigator.userLanguage;
    navigatorLanguage = navigatorLanguage.replace(/^(zh|pt)_/i, '').toLowerCase().substr(0, 2);
    language = "en";
    if (indexOf.call(availableLanguages, navigatorLanguage) >= 0) {
      language = navigatorLanguage;
    }
    $translateProvider.useSanitizeValueStrategy('escaped');
    return $translateProvider.registerAvailableLanguageKeys(availableLanguages).preferredLanguage(language).fallbackLanguage('en');
  }
]);

boothApp.run([
  'questionsAPI', '$rootScope', '$state', '$ionicPlatform', '$window', function(questionsAPI, $rootScope, $state, $ionicPlatform, $window) {
    $rootScope.$on('$stateChangeSuccess', function(event, toState) {
      return $rootScope.state = toState;
    });
    $rootScope.next = function() {
      return questionsAPI.nextQuestion().then(function(id) {
        return $state.go("app.question", {
          id: id
        });
      });
    };
    $rootScope.keydown = function(arg) {
      var keyCode;
      keyCode = arg.keyCode;
      return $rootScope.$broadcast("keydown", keyCode);
    };
    return $ionicPlatform.ready(function() {
      var appCache;
      $rootScope.online = navigator.onLine;
      appCache = $window.applicationCache;
      appCache.addEventListener('progress', function() {
        return $rootScope.cacheStatus = appCache.status;
      });
      appCache.addEventListener('error', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      appCache.addEventListener('cached', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      appCache.addEventListener('updateready', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      return appCache.addEventListener('noupdate', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
    });
  }
]);

boothApp.directive('ngLoad', [
  '$parse', function($parse) {
    return {
      restrict: 'A',
      compile: function($element, attr) {
        var fn;
        fn = $parse(attr['ngLoad']);
        return function(scope, element, attr) {
          return element.on('load', function(event) {
            return scope.$apply(function() {
              return fn(scope, {
                $event: event
              });
            });
          });
        };
      }
    };
  }
]);

var controllers,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

controllers = angular.module("judgebooth.controllers", []);

controllers.controller('SideCtrl', [
  "$scope", "questionsAPI", "$ionicScrollDelegate", "$location", function($scope, questionsAPI, $ionicScrollDelegate, $location) {
    $scope.filter = questionsAPI.filter();
    $scope.languages = questionsAPI.languages();
    $scope.languageCounts = {};
    $scope.offlineMode = window.offlineMode;
    questionsAPI.sets().then(function(response) {
      return $scope.sets = response.data;
    });
    $scope.languageFilter = function(language) {
      return $scope.languageCounts[language.id] > 0;
    };
    questionsAPI.questions().then(function(response) {
      var base, base1, base2, card, i, j, k, l, language, len, len1, len2, len3, len4, m, question, ref, ref1, ref2, set, sets;
      $scope.setCounts = {};
      ref = response.data;
      for (i = 0, len = ref.length; i < len; i++) {
        question = ref[i];
        sets = [];
        ref1 = question.cards;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          card = ref1[j];
          for (k = 0, len2 = card.length; k < len2; k++) {
            set = card[k];
            if (indexOf.call(sets, set) < 0) {
              sets.push(set);
            }
          }
        }
        ref2 = question.languages;
        for (l = 0, len3 = ref2.length; l < len3; l++) {
          language = ref2[l];
          (base = $scope.languageCounts)[language] || (base[language] = 0);
          $scope.languageCounts[language]++;
          for (m = 0, len4 = sets.length; m < len4; m++) {
            set = sets[m];
            (base1 = $scope.setCounts)[language] || (base1[language] = {});
            (base2 = $scope.setCounts[language])[set] || (base2[set] = 0);
            $scope.setCounts[language][set]++;
          }
        }
      }
      return $scope.updateCount();
    });
    $scope.showSets = function() {
      $scope.setsShown = !$scope.setsShown;
      return $ionicScrollDelegate.resize();
    };
    $scope.toggleSet = function(id) {
      var i, j, k, len, len1, len2, ref, ref1, ref2, set;
      if (id === "all" || id === "modern" || id === "standard" || id === "none") {
        $scope.filter.sets = [];
      }
      switch (id) {
        case "standard":
          ref = $scope.sets;
          for (i = 0, len = ref.length; i < len; i++) {
            set = ref[i];
            if (!set.standard) {
              $scope.filter.sets.push(set.id);
            }
          }
          break;
        case "modern":
          ref1 = $scope.sets;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            set = ref1[j];
            if (!set.modern) {
              $scope.filter.sets.push(set.id);
            }
          }
          break;
        case "none":
          ref2 = $scope.sets;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            set = ref2[k];
            $scope.filter.sets.push(set.id);
          }
          break;
        default:
          if (indexOf.call($scope.filter.sets, id) >= 0) {
            $scope.filter.sets.splice($scope.filter.sets.indexOf(id), 1);
          } else {
            $scope.filter.sets.push(id);
          }
      }
      return $scope.updateCount();
    };
    $scope.toggleDifficulty = function(level) {
      if (indexOf.call($scope.filter.difficulty, level) >= 0) {
        $scope.filter.difficulty.splice($scope.filter.difficulty.indexOf(level), 1);
      } else {
        $scope.filter.difficulty.push(level);
      }
      return $scope.updateCount();
    };
    $scope.updateCount = function() {
      var i, len, ref, results, set;
      questionsAPI.filterQuestions($scope.filter, false).then(function(questions) {
        return $scope.filteredQuestions = questions;
      });
      $scope.setCount = Object.keys($scope.setCounts[$scope.filter.language]).length;
      ref = $scope.filter.sets;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        set = ref[i];
        if ($scope.setCounts[$scope.filter.language][set]) {
          results.push($scope.setCount--);
        }
      }
      return results;
    };
    $scope.showQuestions = function() {
      if (!$scope.filteredQuestions.length) {
        return;
      }
      questionsAPI.filter($scope.filter);
      return $scope.next();
    };
    $scope.tab = "filter";
    $scope.user = questionsAPI.user();
    $scope.login = function() {
      return questionsAPI.auth().then(function(auth) {
        if (auth.login != null) {
          window.location.href = auth.login;
        }
        if (auth.role != null) {
          return $scope.user = auth;
        }
      }, function(response) {
        return $scope.user = response.data;
      });
    };
    $scope.logout = function() {
      questionsAPI.logout();
      $scope.user = false;
      return $scope.tab = "filter";
    };
    $scope.toggleTab = function(tab) {
      return $scope.tab = tab;
    };
    if ($location.search().code != null) {
      return questionsAPI.auth($location.search().code).then(function(auth) {
        $location.search('code', null);
        if (auth.redirect != null) {
          $location.path(auth.redirect);
        }
        if (auth.role != null) {
          return $scope.user = auth;
        }
      }, function(response) {
        $location.search('code', null);
        return $scope.user = response.data;
      });
    }
  }
]);

controllers.controller('HomeCtrl', [
  "$scope", "questionsAPI", function($scope, questionsAPI) {
    $scope.sets = [];
    $scope.languages = [];
    $scope.authors = [];
    $scope.questions = [];
    $scope.filtered = [];
    return $scope.$on("$ionicView.enter", function() {
      return questionsAPI.questions().then(function(response) {
        var card, i, j, k, language, len, len1, len2, question, ref, ref1, ref2, results, set;
        $scope.questions = response.data;
        questionsAPI.filterQuestions().then(function(questions) {
          return $scope.filtered = questions;
        });
        ref = $scope.questions;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          question = ref[i];
          if (ref1 = question.author, indexOf.call($scope.authors, ref1) < 0) {
            $scope.authors.push(question.author);
          }
          ref2 = question.cards;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            card = ref2[j];
            for (k = 0, len2 = card.length; k < len2; k++) {
              set = card[k];
              if (indexOf.call($scope.sets, set) < 0) {
                $scope.sets.push(set);
              }
            }
          }
          results.push((function() {
            var l, len3, ref3, results1;
            ref3 = question.languages;
            results1 = [];
            for (l = 0, len3 = ref3.length; l < len3; l++) {
              language = ref3[l];
              if (indexOf.call($scope.languages, language) < 0) {
                results1.push($scope.languages.push(language));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          })());
        }
        return results;
      });
    });
  }
]);

controllers.controller('QuestionCtrl', [
  "$scope", "questionsAPI", "$stateParams", "$state", "$ionicScrollDelegate", function($scope, questionsAPI, $stateParams, $state, $ionicScrollDelegate) {
    var gatherer;
    gatherer = 'http://gatherer.wizards.com/Handlers/Image.ashx?type=card&';
    $scope.$on("$ionicView.enter", function() {
      return questionsAPI.question($stateParams.id).then(function(question) {
        var card, i, len, ref, ref1, results;
        if (!((ref = question.metadata) != null ? ref.id : void 0)) {
          return $state.go("app.home");
        }
        $scope.question = question;
        ref1 = question.cards;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          card = ref1[i];
          card.src = gatherer + 'name=' + card.name;
          if (card.layout === "split") {
            card.src = gatherer + 'name=' + card.full_name;
          }
          if (card.multiverseid) {
            card.src = gatherer + 'multiverseid=' + card.multiverseid;
          }
          if (card.url) {
            card.src = card.url;
          }
          card.manacost = (card.manacost || "").replace(/\{([cwubrgx0-9]+)\}/ig, function(a, b) {
            return "<i class='mtg mana-" + (b.toLowerCase()) + "'></i>";
          }).replace(/\{([2wubrg])\/([wubrg])\}/ig, function(a, b, c) {
            return "<i class='mtg hybrid-" + ((b + c).toLowerCase()) + "'></i>";
          });
          card.text = (card.text || "").replace(/\{([cwubrgx0-9]+)\}/ig, function(a, b) {
            return "<i class='mtg mana-" + (b.toLowerCase()) + "'></i>";
          }).replace(/\{t\}/ig, "<i class='mtg tap'></i>").replace(/\{q\}/ig, "<i class='mtg untap'></i>").replace(/\{([2wubrg])\/([wubrg])\}/ig, function(a, b, c) {
            return "<i class='mtg hybrid-" + ((b + c).toLowerCase()) + "'></i>";
          }).replace(/(\(.*?\))/ig, '<em>$1</em>');
          question.question = question.question.replace(RegExp("(" + card.name + ")", "ig"), "<b>$1</b>");
          results.push(question.answer = question.answer.replace(RegExp("(" + card.name + ")", "ig"), "<b>$1</b>"));
        }
        return results;
      });
    });
    $scope.toggleAnswer = function() {
      $scope.answer = !$scope.answer;
      $ionicScrollDelegate.resize();
      if ($scope.answer) {
        return $ionicScrollDelegate.scrollBottom(true);
      }
    };
    return $scope.$on('keydown', function(event, keycode) {
      switch (keycode) {
        case 37:
          return history.back();
        case 39:
          return $scope.next();
        case 38:
        case 40:
          return $scope.toggleAnswer();
      }
    });
  }
]);

controllers.controller('AdminNewCtrl', [
  "$scope", "questionsAPI", "$stateParams", "$window", function($scope, questionsAPI, $stateParams, $window) {
    $scope.$on("$ionicView.enter", function() {
      return $scope.question = {
        author: $scope.user.name,
        difficulty: "1",
        cards: []
      };
    });
    $scope.add = function() {
      return $scope.question.cards.push({});
    };
    $scope["delete"] = function(index) {
      var message;
      message = "Do you really want to delete '" + $scope.question.cards[index].name + "'?";
      if (!$scope.question.cards[index].id || confirm(message)) {
        return $scope.question.cards.splice(index, 1);
      }
    };
    $scope.suggest = function(card) {
      card.id = "";
      card.preview = false;
      if (card.name.length > 1) {
        return questionsAPI.admin.suggest(card.name).then(function(response) {
          card.suggestions = response.data;
          if (card.suggestions.length === 1) {
            return card.id = card.suggestions[0].id;
          }
        });
      } else {
        return card.suggestions = [];
      }
    };
    $scope.select = function(card, suggestion) {
      card.name = suggestion.name;
      card.id = suggestion.id;
      return delete card.suggestions;
    };
    $scope.keypress = function(event, card) {
      var ref;
      if (event.keyCode === 13) {
        if ((ref = card.suggestions) != null ? ref.length : void 0) {
          $scope.select(card, card.suggestions[0]);
        }
        return event.preventDefault();
      }
    };
    $scope.movecard = function(index, direction) {
      var card;
      card = $scope.question.cards[index];
      $scope.question.cards[index] = $scope.question.cards[index + direction];
      return $scope.question.cards[index + direction] = card;
    };
    $scope.back = function() {
      return $window.history.back();
    };
    return $scope.save = function() {
      var card, i, len, ref;
      ref = $scope.question.cards;
      for (i = 0, len = ref.length; i < len; i++) {
        card = ref[i];
        delete card.suggestions;
      }
      return questionsAPI.admin.save($scope.question).then(function(response) {
        if (response.data === "success") {
          alert("Question submitted");
          questionsAPI.admin.clearShortCache();
          return $scope.question = {
            author: $scope.user.name,
            difficulty: "1",
            cards: []
          };
        } else {
          return alert("Error when submitting question");
        }
      });
    };
  }
]);

controllers.controller('AdminQuestionsCtrl', [
  "$scope", "questionsAPI", "$stateParams", "$state", function($scope, questionsAPI, $stateParams, $state) {
    $scope.page = parseInt($stateParams.page, 10);
    $scope.goto = function() {
      var page;
      page = prompt("Go to page");
      if (page > 0) {
        return $state.go("app.admin.questions", {
          page: page - 1
        });
      }
    };
    $scope.questions = [];
    $scope.reload = function() {
      return questionsAPI.admin.questions($scope.page).then(function(response) {
        $scope.questions = response.data.questions;
        return $scope.pages = response.data.pages;
      }, function() {
        questionsAPI.logout();
        return $state.go("app.home");
      });
    };
    $scope.$on("$ionicView.enter", function() {
      return $scope.reload();
    });
    $scope.languages = questionsAPI.languages();
    $scope.toggle = function(arg) {
      var id, live;
      id = arg.id, live = arg.live;
      return questionsAPI.admin.save({
        id: id,
        live: live
      });
    };
    return $scope["delete"] = function(question) {
      if (confirm("Are you sure?")) {
        return questionsAPI.admin["delete"](question.id).then(function() {
          questionsAPI.admin.clearShortCache();
          question.deleted = true;
          return $scope.reload();
        });
      }
    };
  }
]);

controllers.controller('AdminQuestionCtrl', [
  "$scope", "questionsAPI", "$stateParams", "$window", "$state", function($scope, questionsAPI, $stateParams, $window, $state) {
    $scope.$on("$ionicView.enter", function() {
      return questionsAPI.admin.question($stateParams.id).then(function(response) {
        return $scope.question = response.data;
      }, function() {
        questionsAPI.logout();
        return $state.go("app.home");
      });
    });
    $scope.add = function() {
      return $scope.question.cards.push({});
    };
    $scope["delete"] = function(index) {
      var message;
      message = "Do you really want to delete " + $scope.question.cards[index].name + "?";
      if (!$scope.question.cards[index].id || confirm(message)) {
        return $scope.question.cards.splice(index, 1);
      }
    };
    $scope.suggest = function(card) {
      card.id = "";
      card.preview = false;
      if (card.name.length > 1) {
        return questionsAPI.admin.suggest(card.name).then(function(response) {
          card.suggestions = response.data;
          if (card.suggestions.length === 1) {
            return card.id = card.suggestions[0].id;
          }
        });
      } else {
        return card.suggestions = [];
      }
    };
    $scope.select = function(card, suggestion) {
      card.name = suggestion.name;
      card.id = suggestion.id;
      return delete card.suggestions;
    };
    $scope.keypress = function(event, card) {
      var ref;
      if (event.keyCode === 13) {
        if ((ref = card.suggestions) != null ? ref.length : void 0) {
          $scope.select(card, card.suggestions[0]);
        }
        return event.preventDefault();
      }
    };
    $scope.movecard = function(index, direction) {
      var card;
      card = $scope.question.cards[index];
      $scope.question.cards[index] = $scope.question.cards[index + direction];
      return $scope.question.cards[index + direction] = card;
    };
    $scope.back = function() {
      return $window.history.back();
    };
    return $scope.save = function() {
      var card, i, len, ref;
      ref = $scope.question.cards;
      for (i = 0, len = ref.length; i < len; i++) {
        card = ref[i];
        delete card.suggestions;
      }
      return questionsAPI.admin.save($scope.question).then(function(response) {
        if (response.data === "success") {
          questionsAPI.admin.clearMemoryCache();
          return $scope.back();
        } else {
          return alert("Error when saving question");
        }
      });
    };
  }
]);

controllers.controller('AdminTranslationsCtrl', [
  "$scope", "questionsAPI", "$state", function($scope, questionsAPI, $state) {
    var i, language, len, ref, ref1, ref2;
    $scope.user = questionsAPI.user();
    $scope.selected = {
      language: ((ref = $scope.user) != null ? ref.languages[0] : void 0) || $scope.languages[1].id,
      search: ""
    };
    if (($scope.user != null) && $scope.user.languages.length) {
      $scope.languages = [];
      ref1 = questionsAPI.languages();
      for (i = 0, len = ref1.length; i < len; i++) {
        language = ref1[i];
        if (ref2 = language.id, indexOf.call($scope.user.languages, ref2) >= 0) {
          $scope.languages.push(language);
        }
      }
    }
    $scope.reload = function(clear) {
      if (clear == null) {
        clear = false;
      }
      if (clear) {
        $scope.translations = [];
      }
      if (clear) {
        $scope.selected.search = "";
      }
      return questionsAPI.admin.translations($scope.selected.language).then(function(response) {
        return $scope.translations = response.data;
      }, function() {
        questionsAPI.logout();
        return $state.go("app.home");
      });
    };
    return $scope.$on("$ionicView.enter", function() {
      return $scope.reload();
    });
  }
]);

controllers.controller('AdminTranslationCtrl', [
  "$scope", "$stateParams", "questionsAPI", "$window", "$state", function($scope, $stateParams, questionsAPI, $window, $state) {
    var i, language, len, ref;
    $scope.$on("$ionicView.enter", function() {
      return questionsAPI.admin.translation($stateParams.language, $stateParams.id).then(function(response) {
        return $scope.translation = response.data;
      }, function() {
        questionsAPI.logout();
        return $state.go("app.home");
      });
    });
    ref = $scope.languages;
    for (i = 0, len = ref.length; i < len; i++) {
      language = ref[i];
      if (language.id === parseInt($stateParams.language, 10)) {
        $scope.language = language;
      }
    }
    $scope.back = function() {
      return $window.history.back();
    };
    return $scope.save = function() {
      var translation;
      translation = {
        id: $scope.translation.id,
        language_id: $scope.translation.language_id,
        question: $scope.translation.question_translated,
        answer: $scope.translation.answer_translated
      };
      return questionsAPI.admin.translate(translation).then(function(response) {
        if (response.data === "success") {
          questionsAPI.admin.clearMemoryCache();
          return $scope.back();
        } else {
          return alert("Error when saving question");
        }
      });
    };
  }
]);

controllers.controller('AdminUsersCtrl', [
  "$scope", "questionsAPI", "$state", function($scope, questionsAPI, $state) {
    var i, language, len, ref;
    $scope.languages = [];
    $scope.roles = ["admin", "editor", "translator", "guest"];
    ref = questionsAPI.languages();
    for (i = 0, len = ref.length; i < len; i++) {
      language = ref[i];
      if (language.code !== "en") {
        $scope.languages[language.id] = language;
      }
    }
    $scope.$on("$ionicView.enter", function() {
      return questionsAPI.admin.users().then(function(response) {
        return $scope.users = response.data;
      }, function() {
        questionsAPI.logout();
        return $state.go("app.home");
      });
    });
    $scope.add = function() {
      return $scope.users.push({
        edit: true
      });
    };
    $scope.save = function(index) {
      return questionsAPI.admin.saveUser($scope.users[index]).then(function() {
        return $scope.users[index].edit = false;
      });
    };
    return $scope["delete"] = function(index) {
      if (!(!$scope.users[index].email || confirm("Do you really want to delete this user?"))) {
        return;
      }
      return questionsAPI.admin.deleteUser($scope.users[index].email).then(function() {
        return $scope.users.splice(index, 1);
      });
    };
  }
]);

var services,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

services = angular.module("judgebooth.services", []);

services.service('questionsAPI', [
  "$http", "CacheFactory", "$q", "$translate", "$location", function($http, CacheFactory, $q, $translate, $location) {
    var apiURL, availableLanguages, caches, k, language, len;
    caches = {
      persistent: CacheFactory('persistentCache', {
        storageMode: 'localStorage'
      }),
      short: CacheFactory('shortCache', {
        maxAge: 24 * 3600 * 1000,
        storageMode: 'localStorage',
        deleteOnExpire: 'passive'
      }),
      session: CacheFactory('sessionCache', {
        storageMode: 'sessionStorage'
      }),
      memory: CacheFactory('memoryCache', {
        maxAge: 3600 * 1000,
        capacity: 20,
        deleteOnExpire: 'passive'
      })
    };
    availableLanguages = [
      {
        id: 1,
        code: "en",
        name: "English"
      }, {
        id: 2,
        code: "de",
        name: "German"
      }, {
        id: 3,
        code: "it",
        name: "Italian"
      }, {
        id: 4,
        code: "jp",
        name: "Japanese"
      }, {
        id: 5,
        code: "ko",
        name: "Korean"
      }, {
        id: 6,
        code: "br",
        name: "Portuguese (Brazil)"
      }, {
        id: 7,
        code: "ru",
        name: "Russian"
      }, {
        id: 8,
        code: "es",
        name: "Spanish"
      }, {
        id: 9,
        code: "cn",
        name: "Chinese Simplified"
      }, {
        id: 10,
        code: "tw",
        name: "Chinese Traditional"
      }, {
        id: 11,
        code: "fr",
        name: "French"
      }, {
        id: 12,
        code: "pt",
        name: "Portuguese (Portugal)"
      }
    ];
    apiURL = "backend/?action=";
    if (caches.persistent.get("filter")) {
      for (k = 0, len = availableLanguages.length; k < len; k++) {
        language = availableLanguages[k];
        if (!(language.id === parseInt(caches.persistent.get("filter").language, 10))) {
          continue;
        }
        $translate.use(language.code);
        break;
      }
    }
    return {
      sets: function() {
        return $http.get(apiURL + "sets", {
          cache: caches.short
        });
      },
      languages: function() {
        return availableLanguages;
      },
      questions: function() {
        return $http.get(apiURL + "questions", {
          cache: caches.short
        });
      },
      question: function(id) {
        var deferred, questionPromise;
        deferred = $q.defer();
        language = this.filter().language;
        if (navigator.onLine) {
          $http.get(apiURL + "question&lang=" + language + "&id=" + id, {
            cache: caches.memory
          }).then(function(questionResponse) {
            var question;
            question = questionResponse.data;
            question.language = language;
            return deferred.resolve(question);
          }, function() {
            return deferred.reject();
          });
        } else {
          questionPromise = $http.get(apiURL + "offline", {
            cache: caches.memory
          });
          $q.all([this.questions(), questionPromise]).then(function(arg) {
            var card, cardId, l, len1, len2, m, metadata, question, questionResponse, questionsResponse, ref, ref1, ref2;
            questionsResponse = arg[0], questionResponse = arg[1];
            if (questionResponse.data.questions[id]) {
              question = questionResponse.data.questions[id][language] || questionResponse.data.questions[id][1];
              question.cards = [];
              ref = questionResponse.data.questions[id].cards;
              for (l = 0, len1 = ref.length; l < len1; l++) {
                cardId = ref[l];
                card = questionResponse.data.cards[cardId];
                card.name_en = card.name;
                if ((ref1 = card.translations) != null ? ref1[language] : void 0) {
                  card.name = card.translations[language];
                }
                question.cards.push(card);
              }
              ref2 = questionsResponse.data;
              for (m = 0, len2 = ref2.length; m < len2; m++) {
                metadata = ref2[m];
                if (metadata.id === parseInt(id, 10)) {
                  question.metadata = metadata;
                }
              }
              question.language = language;
              return deferred.resolve(question);
            } else {
              return deferred.reject();
            }
          }, function() {
            return deferred.reject();
          });
        }
        return deferred.promise;
      },
      filter: function(filter) {
        var currentLanguage, filterDefault, l, len1, len2, m, ref;
        ref = this.languages();
        for (l = 0, len1 = ref.length; l < len1; l++) {
          language = ref[l];
          if (language.code === $translate.use()) {
            currentLanguage = language.id;
          }
        }
        filterDefault = {
          language: currentLanguage,
          sets: [],
          difficulty: []
        };
        if (filter != null) {
          for (m = 0, len2 = availableLanguages.length; m < len2; m++) {
            language = availableLanguages[m];
            if (language.id === parseInt(filter.language, 10)) {
              $translate.use(language.code);
            }
          }
          caches.persistent.put("filter", filter);
          caches.memory.remove("filteredQuestions");
        }
        return caches.persistent.get("filter") || filterDefault;
      },
      filterQuestions: function(filter, useCache) {
        var deferred;
        if (useCache == null) {
          useCache = true;
        }
        deferred = $q.defer();
        if (useCache && caches.memory.get("filteredQuestions")) {
          deferred.resolve(caches.memory.get("filteredQuestions"));
        } else {
          filter || (filter = this.filter());
          this.questions().then((function(_this) {
            return function(response) {
              var card, difficulty, filteredQuestions, hasIllegalCard, index, isLegalCard, l, len1, len2, len3, len4, len5, m, n, name1, o, p, question, questions, questionsByDifficulty, ref, ref1, ref2, set;
              questions = response.data;
              questionsByDifficulty = [];
              for (l = 0, len1 = questions.length; l < len1; l++) {
                question = questions[l];
                if (ref = parseInt(filter.language, 10), indexOf.call(question.languages, ref) < 0) {
                  continue;
                }
                if (filter.difficulty.length && (ref1 = question.difficulty, indexOf.call(filter.difficulty, ref1) >= 0)) {
                  continue;
                }
                if (filter.sets.length) {
                  hasIllegalCard = false;
                  ref2 = question.cards;
                  for (m = 0, len2 = ref2.length; m < len2; m++) {
                    card = ref2[m];
                    isLegalCard = false;
                    for (n = 0, len3 = card.length; n < len3; n++) {
                      set = card[n];
                      if (indexOf.call(filter.sets, set) < 0) {
                        isLegalCard = true;
                      }
                    }
                    hasIllegalCard = !isLegalCard;
                    if (hasIllegalCard) {
                      break;
                    }
                  }
                  if (hasIllegalCard) {
                    continue;
                  }
                }
                questionsByDifficulty[name1 = question.difficulty] || (questionsByDifficulty[name1] = []);
                questionsByDifficulty[question.difficulty].push(question.id);
              }
              filteredQuestions = [];
              for (difficulty = o = 0, len4 = questionsByDifficulty.length; o < len4; difficulty = ++o) {
                questions = questionsByDifficulty[difficulty];
                questions = _this.randomize(questions);
                for (index = p = 0, len5 = questions.length; p < len5; index = ++p) {
                  question = questions[index];
                  filteredQuestions[index * questionsByDifficulty.length + difficulty] = question;
                }
              }
              filteredQuestions = filteredQuestions.filter(function(v) {
                return v !== void 0;
              });
              if (useCache) {
                caches.memory.put("filteredQuestions", filteredQuestions);
              }
              return deferred.resolve(filteredQuestions);
            };
          })(this), function() {
            return deferred.reject();
          });
        }
        return deferred.promise;
      },
      nextQuestion: function() {
        var deferred;
        deferred = $q.defer();
        this.filterQuestions().then(function(questions) {
          var question;
          question = questions[0];
          questions.push(questions.shift());
          caches.memory.put("filteredQuestions", questions);
          return deferred.resolve(question);
        }, function() {
          return deferred.reject();
        });
        return deferred.promise;
      },

      /* admin stuff */
      user: function() {
        return caches.session.get("user");
      },
      logout: function() {
        $http.get(apiURL + "logout");
        caches.session.remove("user");
        return caches.session.remove("loginRedirect");
      },
      auth: function(token) {
        var deferred, url;
        deferred = $q.defer();
        url = apiURL + "auth";
        if (token) {
          url += "&token=" + encodeURIComponent(token);
        } else {
          caches.session.put("loginRedirect", $location.path());
        }
        $http.get(url).then(function(response) {
          if (response.data.role != null) {
            caches.session.put('user', response.data);
            response.data.redirect = caches.session.get("loginRedirect");
            caches.session.remove("loginRedirect");
          }
          return deferred.resolve(response.data);
        }, function(response) {
          return deferred.reject(response);
        });
        return deferred.promise;
      },
      randomize: function(arr) {
        var i, j, t;
        if (arr == null) {
          arr = [];
        }
        i = arr.length;
        while (--i > 0) {
          j = ~~(Math.random() * (i + 1));
          t = arr[j];
          arr[j] = arr[i];
          arr[i] = t;
        }
        return arr;
      },
      admin: {
        questions: function(page) {
          return $http.get(apiURL + "admin-questions&page=" + page);
        },
        question: function(id) {
          return $http.get(apiURL + "admin-question&id=" + id);
        },
        suggest: function(name) {
          return $http.get(apiURL + "admin-suggest&name=" + name);
        },
        save: function(question) {
          return $http.post(apiURL + "admin-save", question);
        },
        "delete": function(id) {
          return $http.post(apiURL + "admin-delete&id=" + id);
        },
        translations: function(language) {
          return $http.get(apiURL + "admin-translations&lang=" + language);
        },
        translation: function(language, id) {
          return $http.get(apiURL + "admin-translation&lang=" + language + "&id=" + id);
        },
        translate: function(translation) {
          return $http.post(apiURL + "admin-translate", translation);
        },
        users: function() {
          return $http.get(apiURL + "admin-users");
        },
        saveUser: function(user) {
          return $http.post(apiURL + "admin-saveuser", user);
        },
        deleteUser: function(email) {
          return $http.post(apiURL + "admin-deleteuser&email=" + encodeURIComponent(email));
        },
        clearMemoryCache: function() {
          return caches.memory.removeAll();
        },
        clearShortCache: function() {
          return caches.short.removeAll();
        }
      }
    };
  }
]);
